TODO:
1. 考虑使用状态机重构, 还没有很严格的检查
2. 完善状态检查和错误返回
3. 调试goroutine数量, 因为方便打印了这个数量，加入了net/http/pprof(更方便)

4. 完善单元测试, 逐步完善
 1.) handleshake
 2.) 接收消息
 3.）发送消息,最好自己构造消息


5 relay模块: 实现了当客户向边缘服务器请求某一路rtmp实时流且该流不存在时，会向配置的源服务器请求该rtmp实时流，请求成功后该边缘服务器分发该流给请求的客户，即中继开始；当最后一个请求该rtmp实时流的客户关闭流时，该边缘服务器会自动断开与源服务器该实时流的请求，即中继结束
6 forward: 推流, relay和forward信息其实可以放在data信息里面处理，或者用户控制信息
7 gop缓冲
8 卡顿处理
    1.)对于play：检查chan长度，并丢弃视频帧, 比如chan设置长度为100, 当达到60时候开始丢弃视频帧,知道chan长度回复比如30，然后从下一个关键帧开始放入视频帧
    2.)对于publish: 应该没有好办法处理

后面在考虑
1. 添加log,后续再说，因为log包包含了时间 文件 行数等信息，到时候可以用perl整体替换出来 好处是通过前缀即把方法分组了，
2. 加入prometheus监控， 还未做
3. 考虑方法用反射.  比如对于NetConnect的方法前缀都是 handleNetConnectConnect 这样


关于流媒体cdn的内部转发:
1. 内部网络全部使用tcp bbr流控
2. flv交换数据

优先做:
1. gop缓冲，协程池
   gop缓冲从内存池分配，一个协程池binding一个内存池
   推流和观看的协程也考虑做池化处理

