package mp4

import (
	//"bytes"
	"encoding/hex"
	"fmt"

	"os"
	"testing"

	"github.com/chinasarft/golive/utils/byteio"
)

func TestGenerateHeaderBox(t *testing.T) {

	expectStr := "000000246674797069736f6d0000020069736f6d69736f326176633169736f366d703431000004536d6f6f760000006c6d76" +
		"686400000000d86c7ac6d86c7ac6000003e80000000000010000010000000000000000000000000100000000000000000000" +
		"0000000000010000000000000000000000000000400000000000000000000000000000000000000000000000000000000000" +
		"0003000001ef7472616b0000005c746b686400000003d86c7ac6d86c7ac60000000100000000000000000000000000000000" +
		"000000000000000000010000000000000000000000000000000100000000000000000000000000004000000001e000000120" +
		"00000000018b6d646961000000206d64686400000000d86c7ac6d86c7ac6000003e80000000055c400000000002d68646c72" +
		"000000000000000076797065000000000000000000000000566964656f48616e646c657200000001366d696e660000001476" +
		"6d68640000000100000000000000000000002464696e660000001c6472656600000000000000010000000c75726c20000000" +
		"00000000f67374626c000000aa7374736400000000000000010000009a617663310000000000000001000000000000000000" +
		"0000000000000000000000000000480000004800000000000100000000000000000000000000000000000000000000000000" +
		"000000000000000018ffff00000034617663430142c015ffe1001c6742c015d901e096ffc0040003c4000003000400000300" +
		"c83c58b92001000568cb83cb200000001070617370000000100000000f000000107374747300000000000000000000001073" +
		"7473630000000000000000000000147374737a000000000000000000000000000000107374636f0000000000000000000001" +
		"a87472616b0000005c746b686400000003d86c7ac6d86c7ac600000002000000000000000000000000000000000000000101" +
		"0000000001000000000000000000000000000000010000000000000000000000000000400000000000000000000000000001" +
		"446d646961000000206d64686400000000d86c7ac6d86c7ac600003e800000000055c400000000002d68646c720000000000" +
		"000000736f756e000000000000000000000000536f756e6448616e646c657200000000ef6d696e6600000010736d68640000" +
		"0000000000000000002464696e660000001c6472656600000000000000010000000c75726c2000000000000000b37374626c" +
		"00000067737473640000000000000001000000576d7034610000000000000001000000000000000000020010000000000000" +
		"3e80000000336573647300000000038080802200010004808080144015000000000180000000000005808080021408068080" +
		"8001020000001073747473000000000000000000000010737473630000000000000000000000147374737a00000000000000" +
		"0000000000000000107374636f0000000000000000000000486d766578000000207472657800000000000000010000000100" +
		"00000000000000000000000000002074726578000000000000000200000001000000000000000000000000"
	expByte := make([]byte, len(expectStr)/2)
	_, err := hex.Decode(expByte, []byte(expectStr))
	if err != nil {
		t.Errorf("hex expectStr fail:%s", err)
	}

	str := "0142c015ffe1001c6742c015d901e096ffc0040003c4000003000400000300c83c58b92001000568cb83cb20"
	spsByte := make([]byte, len(str)/2)
	_, err = hex.Decode(spsByte, []byte(str))
	if err != nil {
		t.Errorf("hex avc decoder config fail:%s", err)
	}
	aacSeqHdlr := []byte{0x14, 0x08}

	fmp4 := NewFmp4(1000)
	fmp4.AppendCompatibleBrand(Mp4BoxBrandISOM)
	fmp4.AppendCompatibleBrand(Mp4BoxBrandISO2)
	fmp4.AppendCompatibleBrand(Mp4BoxBrandAVC1)
	fmp4.AppendCompatibleBrand(Mp4BoxBrandISO6)
	fmp4.AppendCompatibleBrand(Mp4BoxBrandMP41)
	if err = fmp4.AddVideoH264Track(spsByte); err != nil {
		t.Fatalf("add h264 track fail:%s\n", err.Error())
	}
	if err = fmp4.AddAudioTrack(aacSeqHdlr); err != nil {
		t.Fatalf("add audio track fail:%s\n", err.Error())
	}

	cnt := make([]byte, 1024)
	for i := 0; i < len(cnt); i++ {
		cnt[i] = 0x30 + uint8(i%9)
	}
	byteio.PutU32BE(cnt, 1020)

	duration := int64(50 * 40)
	fragCount := int64(0)
	audioFrameDuration := int64(1024 * 1000 / 16000)
	for fragCount < 2 {
		fragCount++
		for i := int64(50 * (fragCount - 1)); i < 50*fragCount; i++ {
			if err = fmp4.AddVideoFrameWithLen(cnt, i*40, i%50 == 0); err != nil {
				t.Fatalf("write AddVideoFrameWithLen fail:%s\n", err.Error())
			}
		}

		for i := duration * (fragCount - 1); i < duration*fragCount; i += audioFrameDuration {
			if err = fmp4.AddAudioFrameWithoutLen(cnt[4:1024], i); err != nil {
				t.Fatalf("write AddAudioFrameWithoutLen fail:%s\n", err.Error())
			}
		}
	}

	fmp4.AddVideoFrameWithLen(cnt, duration*fragCount, true)
	/*
		if err = fmp4.generateHeaderBox(); err != nil {
			t.Fatalf("GenerateHeaderBox fail:%s\n", err.Error())
		}
	*/

	headerBoxes := fmp4.headerBox.Bytes()
	if len(expByte) != len(headerBoxes) {
		fmt.Printf("%X\n", expByte)
		fmt.Printf("%X\n", headerBoxes)
		for i := 0; i < len(expByte); i++ {
			if headerBoxes[i] != expByte[i] {
				fmt.Println("index at:", i)
			}
		}
		t.Fatal(" headerBoxes equal expByte's len")
	}

	var file *os.File
	if file, err = os.OpenFile("my.fmp4", os.O_CREATE|os.O_WRONLY, 0644); err != nil {
		t.Fatalf("open file my.fmp4 fail:%s\n", err.Error())
	}
	fmp4.serialize(file)
	file.Close()
}
